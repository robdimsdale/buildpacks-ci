package utils_test

import (
	"github.com/cloudfoundry/buildpacks-ci/cve-notification-app/utils"
	"github.com/sclevine/spec"
	"github.com/sclevine/spec/report"
	"github.com/spf13/afero"
	assertpkg "github.com/stretchr/testify/assert"
	requirepkg "github.com/stretchr/testify/require"
	"testing"
	"time"
)

func TestJSONUtils(t *testing.T) {
	spec.Run(t, "JSON Utils", testJSONUtils, spec.Report(report.Terminal{}))
}

func testJSONUtils(t *testing.T, context spec.G, it spec.S) {
	var (
		assert    = assertpkg.New(t)
		require   = requirepkg.New(t)
		jsonUtils utils.JSONUtils
	)
	context("Calls the NewJSONUtils method", func() {
		context("succeed", func() {
			it.Before(func() {
				jsonUtils = utils.NewJSONUtils("provided-filepath")
			})

			it("returns a new JSONUtils object with provided filepath and default filesystem", func() {
				assert.Equal(jsonUtils.FilePath, "provided-filepath")
				assert.Equal(jsonUtils.FileSystem, afero.NewOsFs())
			})
		})
	})

	context("Calls the GetCVEList method", func() {
		context("succeed", func() {
			it.Before(func() {
				jsonUtils = utils.JSONUtils{
					FilePath:   "some-filepath.json",
					FileSystem: afero.NewMemMapFs(),
				}

				afero.WriteFile(jsonUtils.FileSystem, jsonUtils.FilePath, []byte(`{
  ".net": [
    {
      "ID": "611e9cb69de3ade0714dc270",
      "CreatedAt": "2021-08-19T18:02:30.601Z",
      "UpdatedAt": "2021-08-19T18:02:30.601Z",
      "Vendor": "microsoft",
      "Product": ".net",
      "Severity": "HIGH",
      "CVEId": "CVE-2021-26423",
      "Description": ".NET Core and Visual Studio Denial of Service Vulnerability"
    },
    {
      "ID": "616f0cd358057ce47e8516ea",
      "CreatedAt": "2021-10-19T18:22:11.927Z",
      "UpdatedAt": "2021-10-19T18:22:11.927Z",
      "Vendor": "microsoft",
      "Product": ".net",
      "Severity": "MEDIUM",
      "CVEId": "CVE-2021-41355",
      "Description": ".NET Core and Visual Studio Information Disclosure Vulnerability"
    }
  ],
  "go": [
    {
      "ID": "6113e8cad3bbaa2f868d1c38",
      "CreatedAt": "2021-08-11T15:12:10.854Z",
      "UpdatedAt": "2021-08-11T15:12:10.854Z",
      "Vendor": "golang",
      "Product": "go",
      "Severity": "MEDIUM",
      "CVEId": "CVE-2021-34558",
      "Description": "The crypto/tls package of Go through 1.16.5 does not properly assert that the type of public key in an X.509 certificate matches the expected type when doing a RSA based key exchange, allowing a malicious TLS server to cause a TLS client to panic."
    }
  ]
}`), 0755)
			})

			it("returns the full list of CVEs", func() {
				cveList, err := jsonUtils.GetCVEList()
				require.NoError(err)

				assert.Equal(3, len(cveList))

				dotnetCves := cveList.Filter(func(cve utils.CVE) bool {
					return cve.Product == ".net"
				})

				goCves := cveList.Filter(func(cve utils.CVE) bool {
					return cve.Product == "go"
				})

				assert.True(cveList.Contains(utils.CVE{
					CreatedAt:   "2021-08-19T18:02:30.601Z",
					Vendor:      "microsoft",
					Product:     ".net",
					Severity:    "HIGH",
					CVEId:       "CVE-2021-26423",
					Description: ".NET Core and Visual Studio Denial of Service Vulnerability",
				}), "Expected to find CVE-2021-26423")

				assert.Equal(2, len(dotnetCves))
				assert.Equal(1, len(goCves))
			})
		})

		context("fails", func() {
			context("opening the JSON file", func() {
				it.Before(func() {
					jsonUtils = utils.JSONUtils{
						FilePath:   "some-filepath.csv",
						FileSystem: afero.NewMemMapFs(),
					}
				})

				it("returns a file doesn't exist error", func() {
					_, err := jsonUtils.GetCVEList()
					require.Error(err)

					assert.EqualError(err, "open some-filepath.csv: file does not exist")
				})
			})

			context("reading the JSON file", func() {
				it.Before(func() {
					jsonUtils = utils.JSONUtils{
						FilePath:   "some-filepath.csv",
						FileSystem: afero.NewMemMapFs(),
					}

					afero.WriteFile(jsonUtils.FileSystem, jsonUtils.FilePath, []byte(`a,b"`), 0755)
				})

				it("returns a parse error", func() {
					_, err := jsonUtils.GetCVEList()
					require.Error(err)

					assert.EqualError(err, "invalid character 'a' looking for beginning of value")
				})
			})
		})
	})

	context("Calls the GetRecordedDependencies method", func() {
		context("succeed", func() {
			it.Before(func() {
				jsonUtils = utils.JSONUtils{
					FilePath:   "some-filepath.json",
					FileSystem: afero.NewMemMapFs(),
				}

				afero.WriteFile(jsonUtils.FileSystem, jsonUtils.FilePath, []byte(`{
  ".net": [
    {
      "ID": "611e9cb69de3ade0714dc270",
      "CreatedAt": "2021-08-19T18:02:30.601Z",
      "UpdatedAt": "2021-08-19T18:02:30.601Z",
      "Vendor": "microsoft",
      "Product": ".net",
      "Severity": "HIGH",
      "CVEId": "CVE-2021-26423",
      "Description": ".NET Core and Visual Studio Denial of Service Vulnerability"
    },
    {
      "ID": "616f0cd358057ce47e8516ea",
      "CreatedAt": "2021-10-19T18:22:11.927Z",
      "UpdatedAt": "2021-10-19T18:22:11.927Z",
      "Vendor": "microsoft",
      "Product": ".net",
      "Severity": "MEDIUM",
      "CVEId": "CVE-2021-41355",
      "Description": ".NET Core and Visual Studio Information Disclosure Vulnerability"
    }
  ],
  "go": [
    {
      "ID": "6113e8cad3bbaa2f868d1c38",
      "CreatedAt": "2021-08-11T15:12:10.854Z",
      "UpdatedAt": "2021-08-11T15:12:10.854Z",
      "Vendor": "golang",
      "Product": "go",
      "Severity": "MEDIUM",
      "CVEId": "CVE-2021-34558",
      "Description": "The crypto/tls package of Go through 1.16.5 does not properly assert that the type of public key in an X.509 certificate matches the expected type when doing a RSA based key exchange, allowing a malicious TLS server to cause a TLS client to panic."
    }
  ]
}`), 0755)
			})

			it("returns the list of recorded dependencies", func() {
				depList, err := jsonUtils.GetRecordedDependencies()
				require.NoError(err)

				assert.Equal(2, len(depList))

				assert.Equal("microsoft", depList[0].Vendor)
				assert.Equal(".net", depList[0].Product)

				assert.Equal("golang", depList[1].Vendor)
				assert.Equal("go", depList[1].Product)

			})
		})

		context("fails", func() {
			context("opening the JSON file", func() {
				it.Before(func() {
					jsonUtils = utils.JSONUtils{
						FilePath:   "some-filepath.csv",
						FileSystem: afero.NewMemMapFs(),
					}
				})

				it("returns a file doesn't exist error", func() {
					_, err := jsonUtils.GetRecordedDependencies()
					require.Error(err)

					assert.EqualError(err, "open some-filepath.csv: file does not exist")
				})
			})

			context("reading the JSON file", func() {
				it.Before(func() {
					jsonUtils = utils.JSONUtils{
						FilePath:   "some-filepath.csv",
						FileSystem: afero.NewMemMapFs(),
					}

					afero.WriteFile(jsonUtils.FileSystem, jsonUtils.FilePath, []byte(`a,b"`), 0755)
				})

				it("returns a parse error", func() {
					_, err := jsonUtils.GetRecordedDependencies()
					require.Error(err)

					assert.EqualError(err, "invalid character 'a' looking for beginning of value")
				})
			})
		})
	})

	context.Focus("Calls the GenerateJsonCVEFile method", func() {
		context("succeed", func() {
			it.Before(func() {
				jsonUtils = utils.JSONUtils{
					FilePath:   "some-filepath.json",
					FileSystem: afero.NewMemMapFs(),
				}
			})

			it("generates the JSON file", func() {
				cves := utils.CVEs{
					{
						CreatedAt:   time.Now().Format(time.RFC3339),
						Vendor:      "haxx",
						Product:     "curl",
						Severity:    "HIGH",
						CVEId:       "CVE-1",
						Description: "Testing CVE1",
					},
					{
						CreatedAt:   time.Now().Format(time.RFC3339),
						Vendor:      "golang",
						Product:     "go",
						Severity:    "CRITICAL",
						CVEId:       "CVE-3",
						Description: "Testing CVE3",
					},
				}

				err := jsonUtils.GenerateJsonCVEFile(cves)
				require.NoError(err)

				exists, err := afero.Exists(jsonUtils.FileSystem, "some-filepath.json")
				assert.NoError(err)

				assert.Equal(true, exists)
			})
		})
	})
}
