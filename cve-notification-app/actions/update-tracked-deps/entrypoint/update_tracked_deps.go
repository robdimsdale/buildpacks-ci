package main

import (
	"fmt"
	"github.com/cloudfoundry/buildpacks-ci/cve-notification-app/utils"
	"github.com/jessevdk/go-flags"
	"log"
	"os"
	"strings"
	"time"
)

type AllUtils struct {
	JSONUtils    utils.JSONUtilsInterface
	CSVUtils     utils.CSVUtilsInterface
	NVDNistUtils utils.NVDNistUtilsInterface
}

func main() {
	var opts struct {
		JSONFilePath string `long:"json-filepath" description:"CVEs JSON Filepath" required:"true"`
		DepList      string `long:"dep-list" description:"Path to dependencies.csv file" required:"true"`
	}

	_, err := flags.Parse(&opts)
	if err != nil {
		os.Exit(1)
	}

	allUtils := AllUtils{
		JSONUtils:    utils.NewJSONUtils(opts.JSONFilePath),
		CSVUtils:     utils.NewCSVUtils(opts.DepList),
		NVDNistUtils: utils.NewNVDNistUtils(),
	}

	addedDeps, removedDeps, err := UpdateTrackedDependencies(allUtils)
	if err != nil {
		log.Fatal(err)
	}

	result := ""

	if len(addedDeps) == 0 {
		result += "****Added dependencies:**** \nNone\n"
	} else {
		result += fmt.Sprintf("****Added dependencies:****\n%s\n", strings.Join(addedDeps, "\n"))
	}

	if len(removedDeps) == 0 {
		result += "****Removed dependencies:**** \nNone\n"
	} else {
		result += fmt.Sprintf("****Removed dependencies:****\n%s\n", strings.Join(removedDeps, "\n"))
	}

	fmt.Println(result)
}

func UpdateTrackedDependencies(allUtils AllUtils) ([]string, []string, error) {
	dependenciesInFile, err := allUtils.CSVUtils.GetDependenciesList()
	if err != nil {
		return nil, nil, err
	}

	recordedDependencies, err := allUtils.JSONUtils.GetRecordedDependencies()
	if err != nil {
		return nil, nil, err
	}

	recordedCves, err := allUtils.JSONUtils.GetCVEList()
	if err != nil {
		return nil, nil, err
	}

	addedDependencies := getAddedDependencies(recordedDependencies, dependenciesInFile)
	removedDependencies := getRemovedDependencies(recordedDependencies, dependenciesInFile)

	recordedCves = removeDependencyCVEs(recordedCves, removedDependencies)

	recordedCves, err = addDependencyCVEs(allUtils, recordedCves, addedDependencies)
	if err != nil {
		return nil, nil, err
	}

	err = allUtils.JSONUtils.GenerateJsonCVEFile(recordedCves)
	if err != nil {
		return nil, nil, err
	}

	var (
		addedDeps   []string
		removedDeps []string
	)

	for _, dependency := range addedDependencies {
		addedDeps = append(addedDeps, dependency.Product)
	}

	for _, dependency := range removedDependencies {
		removedDeps = append(removedDeps, dependency.Product)
	}

	return addedDeps, removedDeps, nil
}

func removeDependencyCVEs(cves utils.CVEs, dependencies []utils.DepList) utils.CVEs {
	cvesRemoved := cves

	for _, dependency := range dependencies {
		cvesRemoved = cvesRemoved.FilterNot(func(cve utils.CVE) bool {
			return cve.Product == dependency.Product
		})
	}

	return cvesRemoved
}

func addDependencyCVEs(allUtils AllUtils, cves utils.CVEs, dependencies []utils.DepList) (utils.CVEs, error) {
	cvesAdded := cves

	for _, dependency := range dependencies {
		cves, err := allUtils.NVDNistUtils.GetCVEs(dependency.Vendor, dependency.Product)
		if err != nil {
			return nil, err
		}

		for _, result := range cves.Result.CVEItems {
			cve := utils.CVE{
				CreatedAt:   time.Now().Format(time.RFC3339),
				Vendor:      dependency.Vendor,
				Product:     dependency.Product,
				Severity:    result.Impact.BaseMetricV3.CvssV3.BaseSeverity,
				CVEId:       result.Cve.CVEDataMeta.ID,
				Description: result.Cve.Description.DescriptionData[0].Value,
			}

			cvesAdded = append(cvesAdded, cve)
		}
	}

	return cvesAdded, nil
}

func getRemovedDependencies(trackedDependencies []utils.DepList, dependenciesInFile []utils.DepList) []utils.DepList {
	var removedDependencies []utils.DepList

	for _, trackedDep := range trackedDependencies {
		tracked := false
		for _, depInFile := range dependenciesInFile {
			if depInFile.Product == trackedDep.Product {
				tracked = true
			}
		}

		if !tracked {
			removedDependencies = append(removedDependencies, trackedDep)
		}
	}

	return removedDependencies
}

func getAddedDependencies(trackedDependencies []utils.DepList, dependenciesInFile []utils.DepList) []utils.DepList {
	var addedDependencies []utils.DepList

	for _, depInFile := range dependenciesInFile {
		tracked := false
		for _, trackedDep := range trackedDependencies {
			if depInFile.Product == trackedDep.Product {
				tracked = true
			}
		}

		if !tracked {
			addedDependencies = append(addedDependencies, depInFile)
		}
	}

	return addedDependencies
}
