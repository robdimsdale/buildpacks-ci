package main

import (
	"fmt"
	"github.com/cloudfoundry/buildpacks-ci/cve-notification-app/utils"
	"github.com/jessevdk/go-flags"
	"github.com/spf13/afero"
	"log"
	"os"
	"time"
)

type AllUtils struct {
	JSONUtils    utils.JSONUtilsInterface
	NVDNistUtils utils.NVDNistUtilsInterface
	SlackUtils   utils.SlackUtilsInterface
	CSVUtils     utils.CSVUtilsInterface
	FileSystem   afero.Fs
}

func main() {
	var opts struct {
		SlackWebhookUrl string `long:"webhook-url" description:"Slack webhook URL" required:"true"`
		JSONFilePath    string `long:"json-filepath" description:"CVEs JSON Filepath" required:"true"`
		DepList         string `long:"dep-list" description:"Path to dependencies.csv file" required:"true"`
	}

	_, err := flags.Parse(&opts)
	if err != nil {
		os.Exit(1)
	}

	allUtils := AllUtils{
		JSONUtils:    utils.NewJSONUtils(opts.JSONFilePath),
		NVDNistUtils: utils.NewNVDNistUtils(),
		SlackUtils:   utils.NewSlackUtils(opts.SlackWebhookUrl),
		CSVUtils:     utils.NewCSVUtils(opts.DepList),
		FileSystem:   afero.NewOsFs(),
	}

	newCves, err := FindNewCVEs(allUtils)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(newCves)
}

func FindNewCVEs(allUtils AllUtils) (bool, error) {
	newCves := false

	trackedDependencies, err := allUtils.CSVUtils.GetDependenciesList()
	if err != nil {
		return false, err
	}

	recordedCves, err := allUtils.JSONUtils.GetCVEList()
	if err != nil {
		return false, err
	}

	for _, trackedDep := range trackedDependencies {
		cves, err := allUtils.NVDNistUtils.GetCVEs(trackedDep.Vendor, trackedDep.Product)
		if err != nil {
			return false, err
		}

		for _, cveItem := range cves.Result.CVEItems {
			exists := cveRecorded(cveItem, recordedCves)

			if !exists {
				cve := utils.CVE{
					CreatedAt:   time.Now().Format(time.RFC3339),
					Vendor:      trackedDep.Vendor,
					Product:     trackedDep.Product,
					Severity:    cveItem.Impact.BaseMetricV3.CvssV3.BaseSeverity,
					CVEId:       cveItem.Cve.CVEDataMeta.ID,
					Description: cveItem.Cve.Description.DescriptionData[0].Value,
				}

				recordedCves = append(recordedCves, cve)

				err = allUtils.SlackUtils.SendNewCVENotification(cve.Product, cve.CVEId, cve.Description, cve.Severity)
				if err != nil {
					return false, err
				}

				newCves = true
			}
		}
	}

	if newCves {
		err = allUtils.JSONUtils.GenerateJsonCVEFile(recordedCves)
		if err != nil {
			return false, err
		}
	}

	return newCves, nil
}

func cveRecorded(cveItem utils.NVDNistResponseCVEItem, cves utils.CVEs) bool {
	return cves.Filter(func(cve utils.CVE) bool { return cve.CVEId == cveItem.Cve.CVEDataMeta.ID }).Len() > 0
}
